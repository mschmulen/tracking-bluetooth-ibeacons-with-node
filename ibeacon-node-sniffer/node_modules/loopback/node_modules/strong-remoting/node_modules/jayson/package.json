{
  "name": "jayson",
  "version": "1.0.11",
  "description": "JSON-RPC 2.0 compliant server and client",
  "keywords": [
    "jsonrpc",
    "rpc",
    "json",
    "jsonrpc-2.0",
    "middleware",
    "connect",
    "express",
    "jquery",
    "fork",
    "cluster",
    "distributed",
    "relay"
  ],
  "author": {
    "name": "Tedde Lundgren",
    "email": "mail@tedeh.net",
    "url": "http://tedeh.net"
  },
  "maintainers": "Tedde Lundgren <mail@tedeh.net> (http://tedeh.net)",
  "bin": {
    "jayson": "./bin/jayson.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tedeh/jayson.git"
  },
  "homepage": "http://jayson.tedeh.net",
  "bugs": {
    "url": "https://github.com/tedeh/jayson/issues"
  },
  "main": "index",
  "engines": {
    "node": ">= 0.4.0"
  },
  "contributors": [
    {
      "name": "Tedde Lundgren",
      "email": "mail@tedeh.net",
      "url": "http://tedeh.net"
    },
    {
      "name": "Daniel Vicory",
      "email": "dvicory@gmail.com",
      "url": "http://bzfx.net"
    },
    {
      "name": "Jonathan Liu",
      "email": "net147@gmail.com"
    }
  ],
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "commander": "*",
    "eyes": "*"
  },
  "devDependencies": {
    "should": "*",
    "mocha": "*",
    "connect": "*",
    "uglify-js": "*",
    "blanket": "*"
  },
  "readme": "# Jayson\n\nJayson is a [JSON-RPC 2.0][jsonrpc-spec] compliant server and client written in JavaScript for [node.js][node.js] that aims to be as simple as possible to use.\n\n[jsonrpc-spec]: http://jsonrpc.org/spec.html \n[jsonrpc1-spec]: http://json-rpc.org/wiki/specification\n[node.js]: http://nodejs.org/\n\n## Features\n\n* Servers that can listen to several interfaces at the same time\n* Supports both HTTP and TCP client and server connections\n* jQuery client\n* Relaying of requests to other servers\n* JSON reviving and replacing for transparent serialization of complex objects\n* CLI client\n* Fully tested to comply with the [official JSON-RPC 2.0 specification][jsonrpc-spec]\n* Also supports [JSON-RPC 1.0][jsonrpc1-spec]\n\n## Example\n\nA basic JSON-RPC 2.0 server via HTTP:\n\nServer in `examples/simple_example/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// create a server\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\n// Bind a http interface to the server and let it listen to localhost:3000\nserver.http().listen(3000);\n```\n\nClient in `examples/simple_example/client.js` invoking `add` on the above server:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// create a client\nvar client = jayson.client.http({\n  port: 3000,\n  hostname: 'localhost'\n});\n\n// invoke \"add\"\nclient.request('add', [1, 1], function(err, error, response) {\n  if(err) throw err;\n  console.log(response); // 2!\n});\n```\n\n## Installation\n\nInstall the latest version of _jayson_ from [npm](https://github.com/isaacs/npm) by executing `npm install jayson` in your shell. Do a global install with `npm install --global jayson` if you want the `jayson` client CLI in your PATH.\n\n## Changelog\n\n- *1.0.9*\n  Add support for TCP servers and clients\n\n### CLI client\n\nThere is a CLI client in `bin/jayson.js` and it should be available as `jayson` in your shell if you installed the package with the `--global` switch. Run `jayson --help` to see how it works.\n\n## Requirements\n\nJayson does not have any special dependencies that cannot be resolved with a simple `npm install`. It has been tested with the following node.js versions:\n\n- node.js v0.6.x\n- node.js v0.8.x\n- node.js v0.10.x\n\n## Class documentation\n\nIn addition to this document, a comprehensive class documentation made with [jsdoc][jsdoc-spec] is available at [jayson.tedeh.net](http://jayson.tedeh.net).\n\n[jsdoc-spec]: http://usejsdoc.org/\n\n## Running tests\n\n- Change directory to the repository root\n- Install the testing framework\n  ([mocha](https://github.com/visionmedia/mocha) together with\n  [should](https://github.com/visionmedia/should.js)) by executing `npm install\n  --dev`\n- Run the tests with `make test` or `npm test`\n\n## Usage\n\n### Client\n\nThe client is available as the `Client` or `client` property of `require('jayson')`.\n\n#### Interfaces\n\n* `Client` Base class for interfacing with a server.\n* `Client.tcp` TCP interface\n* `Client.http` HTTP interface.\n* `Client.https` HTTPS interface.\n* `Client.fork` Node.js child_process/fork interface.\n* `Client.jquery` Wrapper around `jQuery.ajax`.\n\n#### Notifications\n\nNotification requests are for cases where the reply from the server is not important and should be ignored. This is accomplished by setting the `id` property of a request object to `null`.\n\nClient in `examples/notifications/client.js` doing a notification request:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar client = jayson.client.http({\n  host: 'localhost',\n  port: 3000\n});\n\n// the third parameter is set to \"null\" to indicate a notification\nclient.request('ping', [], null, function(err) {\n  if(err) throw err;\n  // request was received successfully\n});\n```\nA server in `examples/notifications/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  ping: function(callback) {\n    // do something\n    callback();\n  }\n});\n\nserver.http().listen(3000);\n```\n\n##### Notes\n\n* Any value that the server returns will be discarded when doing a notification request.\n* Omitting the third argument `null` to `Client.prototype.request` does not generate a notification request. This argument has to be set explicitly to `null` for this to happen.\n* Network errors and the like will still reach the callback. When the callback is invoked (with or without error) one can be certain that the server has received the request.\n* See the [Official JSON-RPC 2.0 Specification][jsonrpc-spec] for additional information on how Jayson handles notifications that are erroneous.\n\n#### Batches\n\nA batch request is an array of individual requests that are sent to the server as one. Doing a batch request is very simple in Jayson and consists of constructing an `Array` of individual requests (created by not passing a callback to `Client.prototype.request`) that is then itself passed to `Client.prototype.request`. \n\nClient example in `examples/batch_request/client.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar client = jayson.client.http({\n  host: 'localhost',\n  port: 3000\n});\n\nvar batch = [\n  client.request('does_not_exist', [10, 5]),\n  client.request('add', [1, 1]),\n  client.request('add', [0, 0], null) // a notification\n];\n\n// callback takes two arguments (first type of callback)\nclient.request(batch, function(err, responses) {\n  if(err) throw err;\n  // responses is an array of errors and successes together\n  console.log('responses', responses);\n});\n\n// callback takes three arguments (second type of callback)\nclient.request(batch, function(err, errors, successes) {\n  if(err) throw err;\n  // errors is an array of the requests that errored\n  console.log('errors', errors);\n  // successes is an array of requests that succeded\n  console.log('successes', successes);\n});\n```\n\nServer example in `examples/batch_request/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\nserver.http().listen(3000);\n```\n\n##### Notes\n\n* See the [Official JSON-RPC 2.0 Specification][jsonrpc-spec] for additional information on how Jayson handles different types of batches, mainly with regards to notifications, request errors and so forth.\n* There is no guarantee that the results will be in the same order as request Array `request`. To find the right result, compare the ID from the request with the ID in the result yourself.\n\n#### Client callback syntactic sugar\n\nWhen the length (number of arguments) of a client callback function is either 2 or 3 it receives slightly different values when invoked.\n\n* 2 arguments: first argument is an error or `null`, second argument is the response object as returned (containing _either_ a `result` or a `error` property) or `null` for notifications.\n* 3 arguments: first argument is an error or null, second argument is a JSON-RPC `error` property or `null` (if success), third argument is a JSON-RPC `result` property or `null` (if error).\n\nWhen doing a batch request with a 3-length callback, the second argument will be an array of requests with a `error` property and the third argument will be an array of requests with a `result` property.\n\n#### Client events\n\nA client will emit the following events (in addition to any special ones emitted by a specific interface):\n\n* `request` Emitted when a client is just about to dispatch a request. First argument is the request object.\n* `response` Emitted when a client has just received a reponse. First argument is the request object, second argument is the response as received.\n\n#### Client interfaces and options\n\nEvery client supports these options:\n\n* `reviver` -> Function to use as a JSON reviver\n* `replacer` -> Function to use as a JSON replacer\n* `generator` -> Function to generate request ids with. If omitted, Jayson will just generate a \"random\" number that is [RFC4122] compliant and looks like this: `3d4be346-b5bb-4e28-bc4a-0b721d4f9ef9`\n* `version` -> Can be either `1` or `2` depending on which specification should be followed in communicating with the server. Defaults to `2` for [JSON-RPC 2.0][jsonrpc-spec]\n\n[rfc_4122_spec]: http://www.ietf.org/rfc/rfc4122.txt\n\n##### Client.http\n\nUses the same options as [http.request][nodejs_docs_http_request] in addition to these options:\n\n* `encoding` -> String that determines the encoding to use and defaults to utf8\n\nIt is possible to pass a string URL as the first argument. The URL will be run through [url.parse][nodejs_docs_url_parse]. Example:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar client = jayson.client.http('http://localhost:3000');\n// client.options is now the result of url.parse\n```\n\n[nodejs_docs_http_request]: http://nodejs.org/docs/latest/api/http.html#http_http_request_options_callback\n[nodejs_docs_url_parse]: http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost\n\n##### Client.https\n\nUses the same options as [https.request][nodejs_docs_https_request] in addition _to the same options as `Client.http`_. This means it is also possible\nto pass a string URL as the first argument and have it interpreted by [url.parse][nodejs_docs_url_parse].\n\n[nodejs_docs_https_request]: http://nodejs.org/api/all.html#all_https_request_options_callback\n\n##### Client.tcp\n\nUses the same options as the base class.\n\n##### Client.fork\n\nUses the same options as the base class.\n\n##### Client.jquery\n\nThe jQuery Client is stand-alone from the other classes and should preferably be compiled with `make compile` which outputs different flavors into the `build` directory. Supports inclusion via AMD. Uses the same options as [jQuery.ajax][jquery_docs_ajax] and exposes itself as $.jayson with the same arguments as `Client.prototype.request`.\n\n[jquery_docs_ajax]: http://api.jquery.com/jQuery.ajax/\n\n### Server\n\nThe server classes are available as the `Server` or `server` property of `require('jayson')`.\n\nThe server also sports several interfaces that can be accessed as properties of an instance of `Server`.\n\n#### Server interfaces and options\n\n* `Server` - Base interface for a server that supports receiving JSON-RPC 2.0 requests.\n* `Server.tcp` - TCP server that inherits from [net.Server][nodejs_doc_net_server].\n* `Server.http` - HTTP server that inherits from [http.Server][nodejs_doc_http_server].\n* `Server.https` - HTTPS server that inherits from [https.Server][nodejs_doc_https_server].\n* `Server.middleware` - Method that returns a [Connect][connect]/[Express][express] compatible middleware function.\n* `Server.fork` Creates a child process that can take requests via `client.fork`\n\n[nodejs_doc_net_server]: http://nodejs.org/docs/latest/api/net.html#net_class_net_server\n[nodejs_doc_http_server]: http://nodejs.org/docs/latest/api/http.html#http_class_http_server\n[nodejs_doc_https_server]: http://nodejs.org/docs/latest/api/https.html#https_class_https_server\n[connect]: http://www.senchalabs.org/connect/\n[express]: http://expressjs.com/\n\nEvery server supports these options:\n\n* `reviver` -> Function to use as a JSON reviver\n* `replacer` -> Function to use as a JSON replacer\n* `version` -> Can be either `1` or `2` depending on which specification clients are expected to follow. Defaults to `2` for [JSON-RPC 2.0][jsonrpc-spec]\n\n#### Using many server interfaces at the same time\n\nA Jayson server can use many interfaces at the same time.\n\nServer in `examples/many_interfaces/server.js` that listens to both `http` and a `https` requests:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    return callback(null, a + b);\n  }\n});\n\n// \"http\" will be an instance of require('http').Server\nvar http = server.http();\n\n// \"https\" will be an instance of require('https').Server\nvar https = server.https({\n  //cert: require('fs').readFileSync('cert.pem'),\n  //key require('fs').readFileSync('key.pem')\n});\n\nhttp.listen(80, function() {\n  console.log('Listening on *:80')\n});\n\nhttps.listen(443, function() {\n  console.log('Listening on *:443')\n});\n```\n\n#### Using the server as a relay\n\nPassing an instance of a client as a method to the server makes the server relay incoming requests to wherever the client is pointing to. This might be used to delegate computationally expensive functions into a separate fork/server or to abstract a cluster of servers behind a common interface.\n\nPublic server in `examples/relay/server_public.js` listening on `*:3000`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// create a server where \"add\" will relay a localhost-only server\nvar server = jayson.server({\n  add: jayson.client.http({\n    hostname: 'localhost',\n    port: 3001\n  })\n});\n\n// let the server listen to *:3000\nserver.http().listen(3000, function() {\n  console.log('Listening on *:3000');\n});\n```\n\nPrivate server in `examples/relay/server_private.js` listening on localhost:3001:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\n// let the private server listen to localhost:3001\nserver.http().listen(3001, '127.0.0.1', function() {\n  console.log('Listening on 127.0.0.1:3001');\n});\n```\n\nEvery request to `add` on the public server will now relay the request to the private server. See the client example in `examples/relay/client.js`.\n\n#### Server events\n\nIn addition to events that are specific to certain interfaces, all servers will emit the following events:\n\n* `request` Emitted when the server receives an interpretable (non-batch) request. First argument is the request object.\n* `response` Emitted when the server is returning a response. First argument is the request object, the second is the response object.\n* `batch` Emitted when the server receives a batch request. First argument is an array of requests. Will emit `request` for each interpretable request in the batch.\n\n#### Errors\n\nIf you should like to return an error from an method request to indicate a failure, remember that the [JSON-RPC 2.0][jsonrpc-spec] specification requires the error to be an `Object` with a `code (Integer/Number)` to be regarded as valid. You can also provide a `message (String)` and a `data (Object)` with additional information. Example: \n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  i_cant_find_anything: function(id, callback) {\n    var error = {code: 404, message: 'Cannot find ' + id};\n    callback(error); // will return the error object as given\n  },\n  i_cant_return_a_valid_error: function(callback) {\n    callback({message: 'I forgot to enter a code'}); // will return a pre-defined \"Internal Error\"\n  }\n});\n```\n\n##### Predefined Errors\n\nIt is also possible to cause a method to return one of the predefined [JSON-RPC 2.0 error codes][jsonrpc-spec#error_object] using the server helper function `Server.prototype.error` inside of a server method. Example:\n\n[jsonrpc-spec#error_object]: http://jsonrpc.org/spec.html#error_object\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  invalid_params: function(id, callback) {\n    var error = this.error(-32602); // returns an error with the default properties set\n    callback(error);\n  }\n});\n```\n\nYou can even override the default messages:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  error_giver_of_doom: function(callback) {\n    callback(true) // invalid error format, which causes an Internal Error to be returned instead\n  }\n});\n\n// Override the default message\nserver.errorMessages[Server.errors.INTERNAL_ERROR] = 'I has a sad. I cant do anything right';\n```\n\n### Revivers and Replacers\n\nJSON lacks support for representing types other than the simple ones defined in the [JSON specification][jsonrpc-spec]. Fortunately the JSON methods in JavaScript (`JSON.parse` and `JSON.stringify`) provide options for custom serialization/deserialization routines. Jayson allows you to pass your own routines as options to both clients and servers.\n\nSimple example transferring the state of an object between a client and a server:\n\nShared code between the server and the client in `examples/reviving_and_replacing/shared.js`:\n\n```javascript\nvar Counter = exports.Counter = function(value) {\n  this.count = value || 0;\n};\n\nCounter.prototype.increment = function() {\n  this.count += 1;\n};\n\nexports.replacer = function(key, value) {\n  if(value instanceof Counter) {\n    return {$class: 'counter', $props: {count: value.count}};\n  }\n  return value;\n};\n\nexports.reviver = function(key, value) {\n  if(value && value.$class === 'counter') {\n    var obj = new Counter;\n    for(var prop in value.$props) obj[prop] = value.$props[prop];\n    return obj;\n  }\n  return value;\n};\n```\n\nServer in `examples/reviving_and_replacing/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar shared = require('./shared');\n\n// Set the reviver/replacer options\nvar options = {\n  reviver: shared.reviver,\n  replacer: shared.replacer\n};\n\n// create a server\nvar server = jayson.server({\n  increment: function(counter, callback) {\n    counter.increment();\n    callback(null, counter);\n  }\n}, options);\n\n// let the server listen to for http connections on localhost:3000\nserver.http().listen(3000);\n```\n\nA client in `examples/reviving_and_replacing/client.js` invoking \"increment\" on the server:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar shared = require('./shared');\n\n// create a client with the shared reviver and replacer\nvar client = jayson.client.http({\n  port: 3000,\n  hostname: 'localhost',\n  reviver: shared.reviver,\n  replacer: shared.replacer\n});\n\n// create the object\nvar instance = new shared.Counter(2);\n\n// invoke \"increment\"\nclient.request('increment', [instance], function(err, error, result) {\n  if(err) throw err;\n  console.log(result instanceof shared.Counter); // true\n  console.log(result.count); // 3!\n  console.log(instance === result); // false - it won't be the same object, naturally\n});\n```\n\n##### Notes\n\n* Instead of using a replacer, it is possible to define a `toJSON` method for any JavaScript object. Unfortunately there is no corresponding method for reviving objects (that would not work, obviously), so the _reviver_ always has to be set up manually.\n\n### Forking\n\nIt is possible (and _simple_) to create automatic forks with jayson using the node.js `child_process` core library. This might be used for expensive or blocking calculations and to provide some separation from the main server thread.\n\nThe forking server class is available as `jayson.Server.Fork` and takes a file as the first option. This file will be require'd by jayson and should export any methods that are to be made available to clients.\n\nThe main server in `examples/forking/server.js`\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// creates a fork\nvar fork = jayson.server.fork(__dirname + '/fork');\n\nvar front = jayson.server({\n  fib: jayson.client.fork(fork) // connects \"fib\" to the fork\n});\n\n// let the front server listen to localhost:3000\nfront.http().listen(3000);\n```\n\nThe forked server in `examples/forking/fork.js`\n\n```javascript\n// export \"fib\" for forking\nexports.fib = function(n, callback) {\n  function fib(n) {\n    if(n < 2) return n;\n    return fib(n - 1) + fib(n - 2);\n  };\n  var result = fib(n);\n  callback(null, fib(n));\n};\n```\n\nA client doing a fibonacci request in `examples/forking/client.js`\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar client = jayson.client.http({\n  port: 3000,\n  hostname: 'localhost'\n});\n\n// request \"fib\" on the server\nclient.request('fib', [15], function(err, response) {\n  console.log(response);\n});\n```\n\n#### Notes\n\n* A child_process is spawned immediately \n* To specify options (such as a reviver and a replacer) for the forked server, `module.exports` an instance of `jayson.Server` instead of exporting plain methods.\n\n### Contributing\n\nHighlighting [issues](https://github.com/tedeh/jayson/issues) or submitting pull\nrequests on [Github](https://github.com/tedeh/jayson) is most welcome.\n",
  "readmeFilename": "README.md",
  "_id": "jayson@1.0.11",
  "_from": "jayson@~1.0.11"
}
